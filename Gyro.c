#pragma config(Sensor, in8,    gyroSensor,     sensorGyro)
#pragma config(Motor,  port2,           frontL,        tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, None)
#pragma config(Motor,  port3,           backL,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           frontR,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           backR,         tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task initialize(){
	SensorValue(gyroSensor) = sensorNone;
	SensorValue(gyroSensor) = gyroSensor;
}

//place holder until I find Motor control code
void turn (char side) {
	/*
	int speed = 0;
	if (side == 'l' || side == 'L') {
	speed = 50;
	}
	else if (side == 'r' || side == 'R') {
	speed = -50;
	}
	motor[frontL] = speed;
	motor[backL] = speed;
	motor[frontR] = -speed;
	motor[backR] = -speed;


	*/
}

//generic turn method, Ã  la DRY
void turnBy (int degrees, char side) {

	int degrees10 = degrees * 10;
	//clear sensor value
	SensorType[gyroSensor] = sensorNone;
	SensorValue[gyroSensor] = sensorGyro;

	while (abs(SensorValue[gyroSensor]) < degrees10) { 

		turn(side);
	}	
}

//what should be called if robot wants to turn left or right by specified amount
void turnLeftBy(int degrees)
{ 
	turnBy(degrees,'L');
}

void turnRightBy(int degrees)
{ 
	turnBy(degrees, 'R');	

}





//Tests the gyro sensor. Makes the robot turn left 90 degrees, and then return into the starting postion.

task gyroTest()
{
	int degrees = 90;
	turnLeftBy(degrees);
	wait1Msec(200);
	turnRightBy(degrees);
	wait1Msec(500);
}


task main() {

	while(true) {
		startTask(initialize);
		startTask(gyroTest);
	}
}
